<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>degann.search_algorithms.simulated_annealing API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>degann.search_algorithms.simulated_annealing</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import math
import random
from itertools import product
from typing import Callable, Tuple

from .nn_code import alph_n_full, alphabet_activations, decode
from degann.networks import imodel
from degann.search_algorithms.generate import (
    generate_neighbor,
    random_generate,
    choose_neighbor,
)
from .utils import log_to_file, update_random_generator


def temperature_lin(k: int, k_max: int, **kwargs) -&gt; float:
    &#34;&#34;&#34;
    Calculate new temperature for simulated annealing as *1 - (k + 1) / k_max*

    Parameters
    ----------
    k: float
        Current iteration
    k_max: float
        Amount of all iterations

    Returns
    -------
    new_t: float
        New temperature
    &#34;&#34;&#34;
    return 1 - (k + 1) / k_max


def distance_const(d: float) -&gt; Callable:
    &#34;&#34;&#34;
    Calculate distance to neighbour for simulated annealing as constant

    Parameters
    ----------
    d: float
        Constant distance

    Returns
    -------
    d_c: Callable
        Function returning a constant distance
    &#34;&#34;&#34;

    def d_c(**kwargs) -&gt; float:
        return d

    return d_c


def temperature_exp(alpha: float) -&gt; Callable[[float], float]:
    &#34;&#34;&#34;
    Calculate new temperature for simulated annealing as *t * alpha*

    Parameters
    ----------
    alpha: float
        Exponential exponent

    Returns
    -------
    t_e: Callable[[float], float]
        Temperature function
    &#34;&#34;&#34;

    def t_e(t: float, **kwargs) -&gt; float:
        &#34;&#34;&#34;
        Parameters
        ----------
        t: float
            Current temperature

        Returns
        -------
        new_t: float
            New temperature
        &#34;&#34;&#34;
        return t * alpha

    return t_e


def distance_lin(offset, multiplier):
    &#34;&#34;&#34;
    Calculate distance to neighbour for simulated annealing as *offset + temperature * multiplier*

    Parameters
    ----------
    offset: float
    multiplier: float

    Returns
    -------
    d_l: Callable
        Function returning a new distance depending on current temperature
    &#34;&#34;&#34;

    def d_l(temperature, **kwargs):
        return offset + temperature * multiplier

    return d_l


def simulated_annealing(
    input_size: int,
    output_size: int,
    data: tuple,
    val_data: tuple = None,
    max_iter: int = 100,
    threshold: float = -1,
    start_net: dict = None,
    method_for_generate_next_nn: Callable = generate_neighbor,
    temperature_method: Callable = temperature_lin,
    distance_method: Callable = distance_const(150),
    min_epoch: int = 100,
    max_epoch: int = 700,
    opt: str = &#34;Adam&#34;,
    loss: str = &#34;Huber&#34;,
    nn_min_length: int = 1,
    nn_max_length: int = 6,
    nn_alphabet: list[str] = [
        &#34;&#34;.join(elem) for elem in product(alph_n_full, alphabet_activations)
    ],
    alphabet_block_size: int = 1,
    alphabet_offset: int = 8,
    update_gen_cycle: int = 0,
    callbacks: list = None,
    file_name: str = &#34;&#34;,
    logging: bool = False,
) -&gt; Tuple[float, int, str, str, dict, int]:
    &#34;&#34;&#34;
    Method of simulated annealing in the parameter space of neural networks
    
    Parameters
    ----------
    input_size: int
       Size of input data
    output_size: int
        Size of output data
    data: tuple
        dataset
    val_data: tuple
        Validation dataset
    max_iter: int
        Training will stop when the number of iterations of the algorithm exceeds this parameter
    threshold: float
        Training will stop when the value of the loss function is less than this threshold
    start_net: dict
        Start point in parameter space of neural networks, if None it will be random generated
    method_for_generate_next_nn: Callable
        Method for obtaining the next point in parameter space of neural networks
    temperature_method: Callable
        Temperature decreasing method in SAM
    distance_method: Callable
        Method that sets the boundaries of the neighborhood around the current point
    min_epoch: int
        Lower bound of epochs
    max_epoch: int
        Upper bound of epochs
    opt: str
        Name of optimizer
    loss: str
        Name of loss function
    nn_min_length: int
        Starting number of hidden layers of neural networks
    nn_max_length: int
        Final number of hidden layers of neural networks
    nn_alphabet: list
        List of possible sizes of hidden layers with activations for them
    alphabet_block_size: int
        Number of literals in each `alphabet` symbol that indicate the size of hidden layer
    alphabet_offset: int
        Indicate the minimal number of neurons in hidden layer
    update_gen_cycle: int
        Refresh tensorflow random generator per update_gen_cycle
    callbacks: list
        Callbacks for neural networks training
    file_name: str
        Path to file for logging
    logging: bool
        Logging search process to file

    Returns
    -------
    search_results: tuple[float, int, str, str, dict]
        Results of the algorithm are described by these parameters

        best_loss: float
            The value of the loss function during training of the best neural network
        best_epoch: int
            Number of training epochs for the best neural network
        best_loss_func: str
            Name of the loss function of the best neural network
        best_opt: str
            Name of the optimizer of the best neural network
        best_net: dict
            Best neural network presented as a dictionary
    &#34;&#34;&#34;
    gen = random_generate(
        min_epoch=min_epoch,
        max_epoch=max_epoch,
        min_length=nn_min_length,
        max_length=nn_max_length,
        alphabet=nn_alphabet,
    )
    if start_net is None:
        b, a = decode(
            gen[0].value(), block_size=alphabet_block_size, offset=alphabet_offset
        )
        curr_best = imodel.IModel(input_size, b, output_size, a + [&#34;linear&#34;])
        curr_best.compile(optimizer=opt, loss_func=loss)
    else:
        curr_best = imodel.IModel(input_size, [], output_size, [&#34;linear&#34;])
        curr_best = curr_best.from_dict(start_net)
    curr_epoch = gen[1].value()
    hist = curr_best.train(
        data[0], data[1], epochs=curr_epoch, verbose=0, callbacks=callbacks
    )
    curr_loss = hist.history[&#34;loss&#34;][-1]
    best_val_loss = (
        curr_best.evaluate(val_data[0], val_data[1], verbose=0, return_dict=True)[
            &#34;loss&#34;
        ]
        if val_data is not None
        else None
    )
    best_epoch = curr_epoch
    best_nn = curr_best.to_dict()
    best_gen = gen
    best_a = curr_best.get_activations
    best_loss = curr_loss

    history = dict()
    history[&#34;shapes&#34;] = [curr_best.get_shape]
    history[&#34;activations&#34;] = [best_a]
    history[&#34;code&#34;] = [best_gen[0].value()]
    history[&#34;epoch&#34;] = [best_gen[1].value()]
    history[&#34;optimizer&#34;] = [opt]
    history[&#34;loss function&#34;] = [loss]
    history[&#34;loss&#34;] = [curr_loss]
    history[&#34;validation loss&#34;] = [best_val_loss]
    history[&#34;train_time&#34;] = [curr_best.network.trained_time[&#34;train_time&#34;]]
    if logging:
        fn = f&#34;{file_name}_{len(data[0])}_0_{loss}_{opt}&#34;
        log_to_file(history, fn)

    k = 0
    t = 1
    while k &lt; max_iter - 1 and curr_loss &gt; threshold:
        history = dict()

        update_random_generator(k, cycle_size=update_gen_cycle)
        t = temperature_method(k=k, k_max=max_iter, t=t)
        distance = distance_method(temperature=t)

        gen_neighbor = choose_neighbor(
            method_for_generate_next_nn,
            alphabet=nn_alphabet,
            parameters=(gen[0].value(), gen[1].value()),
            distance=distance,
            min_epoch=min_epoch,
            max_epoch=max_epoch,
            min_length=nn_min_length,
            max_length=nn_max_length,
        )
        b, a = decode(
            gen_neighbor[0].value(),
            block_size=alphabet_block_size,
            offset=alphabet_offset,
        )
        neighbor = imodel.IModel(input_size, b, output_size, a + [&#34;linear&#34;])
        neighbor.compile(optimizer=opt, loss_func=loss)
        neighbor_hist = neighbor.train(
            data[0],
            data[1],
            epochs=gen_neighbor[1].value(),
            verbose=0,
            callbacks=callbacks,
        )
        neighbor_val_loss = (
            neighbor.evaluate(val_data[0], val_data[1], verbose=0, return_dict=True)[
                &#34;loss&#34;
            ]
            if val_data is not None
            else None
        )
        neighbor_loss = neighbor_hist.history[&#34;loss&#34;][-1]

        if (
            neighbor_loss &lt; curr_loss
            or math.e ** ((curr_loss - neighbor_loss) / t) &gt; random.random()
        ):
            curr_best = neighbor
            gen = gen_neighbor
            curr_epoch = gen_neighbor[1].value()
            curr_loss = neighbor_loss
            curr_val_loss = neighbor_val_loss

            if curr_loss &lt; best_loss:
                best_loss = curr_loss
                best_epoch = curr_epoch
                best_nn = curr_best.to_dict()
                best_gen = gen
                best_a = a.copy()
                best_val_loss = curr_val_loss
        k += 1

        history[&#34;shapes&#34;] = [neighbor.get_shape]
        history[&#34;activations&#34;] = [a]
        history[&#34;code&#34;] = [gen_neighbor[0].value()]
        history[&#34;epoch&#34;] = [gen_neighbor[1].value()]
        history[&#34;optimizer&#34;] = [opt]
        history[&#34;loss function&#34;] = [loss]
        history[&#34;loss&#34;] = [neighbor_loss]
        history[&#34;validation loss&#34;] = [neighbor_val_loss]
        history[&#34;train_time&#34;] = [neighbor.network.trained_time[&#34;train_time&#34;]]
        if logging:
            fn = f&#34;{file_name}_{len(data[0])}_0_{loss}_{opt}&#34;
            log_to_file(history, fn)
    return best_loss, best_epoch, loss, opt, best_nn, k</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="degann.search_algorithms.simulated_annealing.distance_const"><code class="name flex">
<span>def <span class="ident">distance_const</span></span>(<span>d: float) ‑> Callable</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate distance to neighbour for simulated annealing as constant</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>d</code></strong> :&ensp;<code>float</code></dt>
<dd>Constant distance</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>d_c</code></strong> :&ensp;<code>Callable</code></dt>
<dd>Function returning a constant distance</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distance_const(d: float) -&gt; Callable:
    &#34;&#34;&#34;
    Calculate distance to neighbour for simulated annealing as constant

    Parameters
    ----------
    d: float
        Constant distance

    Returns
    -------
    d_c: Callable
        Function returning a constant distance
    &#34;&#34;&#34;

    def d_c(**kwargs) -&gt; float:
        return d

    return d_c</code></pre>
</details>
</dd>
<dt id="degann.search_algorithms.simulated_annealing.distance_lin"><code class="name flex">
<span>def <span class="ident">distance_lin</span></span>(<span>offset, multiplier)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate distance to neighbour for simulated annealing as <em>offset + temperature * multiplier</em></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>offset</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>multiplier</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>d_l</code></strong> :&ensp;<code>Callable</code></dt>
<dd>Function returning a new distance depending on current temperature</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distance_lin(offset, multiplier):
    &#34;&#34;&#34;
    Calculate distance to neighbour for simulated annealing as *offset + temperature * multiplier*

    Parameters
    ----------
    offset: float
    multiplier: float

    Returns
    -------
    d_l: Callable
        Function returning a new distance depending on current temperature
    &#34;&#34;&#34;

    def d_l(temperature, **kwargs):
        return offset + temperature * multiplier

    return d_l</code></pre>
</details>
</dd>
<dt id="degann.search_algorithms.simulated_annealing.simulated_annealing"><code class="name flex">
<span>def <span class="ident">simulated_annealing</span></span>(<span>input_size: int, output_size: int, data: tuple, val_data: tuple = None, max_iter: int = 100, threshold: float = -1, start_net: dict = None, method_for_generate_next_nn: Callable = &lt;function generate_neighbor&gt;, temperature_method: Callable = &lt;function temperature_lin&gt;, distance_method: Callable = &lt;function distance_const.&lt;locals&gt;.d_c&gt;, min_epoch: int = 100, max_epoch: int = 700, opt: str = 'Adam', loss: str = 'Huber', nn_min_length: int = 1, nn_max_length: int = 6, nn_alphabet: list[str] = ['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc'], alphabet_block_size: int = 1, alphabet_offset: int = 8, update_gen_cycle: int = 0, callbacks: list = None, file_name: str = '', logging: bool = False) ‑> Tuple[float, int, str, str, dict, int]</span>
</code></dt>
<dd>
<div class="desc"><p>Method of simulated annealing in the parameter space of neural networks</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>input_size</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
<dt>Size of input data</dt>
<dt><strong><code>output_size</code></strong> :&ensp;<code>int</code></dt>
<dd>Size of output data</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>tuple</code></dt>
<dd>dataset</dd>
<dt><strong><code>val_data</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Validation dataset</dd>
<dt><strong><code>max_iter</code></strong> :&ensp;<code>int</code></dt>
<dd>Training will stop when the number of iterations of the algorithm exceeds this parameter</dd>
<dt><strong><code>threshold</code></strong> :&ensp;<code>float</code></dt>
<dd>Training will stop when the value of the loss function is less than this threshold</dd>
<dt><strong><code>start_net</code></strong> :&ensp;<code>dict</code></dt>
<dd>Start point in parameter space of neural networks, if None it will be random generated</dd>
<dt><strong><code>method_for_generate_next_nn</code></strong> :&ensp;<code>Callable</code></dt>
<dd>Method for obtaining the next point in parameter space of neural networks</dd>
<dt><strong><code>temperature_method</code></strong> :&ensp;<code>Callable</code></dt>
<dd>Temperature decreasing method in SAM</dd>
<dt><strong><code>distance_method</code></strong> :&ensp;<code>Callable</code></dt>
<dd>Method that sets the boundaries of the neighborhood around the current point</dd>
<dt><strong><code>min_epoch</code></strong> :&ensp;<code>int</code></dt>
<dd>Lower bound of epochs</dd>
<dt><strong><code>max_epoch</code></strong> :&ensp;<code>int</code></dt>
<dd>Upper bound of epochs</dd>
<dt><strong><code>opt</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of optimizer</dd>
<dt><strong><code>loss</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of loss function</dd>
<dt><strong><code>nn_min_length</code></strong> :&ensp;<code>int</code></dt>
<dd>Starting number of hidden layers of neural networks</dd>
<dt><strong><code>nn_max_length</code></strong> :&ensp;<code>int</code></dt>
<dd>Final number of hidden layers of neural networks</dd>
<dt><strong><code>nn_alphabet</code></strong> :&ensp;<code>list</code></dt>
<dd>List of possible sizes of hidden layers with activations for them</dd>
<dt><strong><code>alphabet_block_size</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of literals in each <code>alphabet</code> symbol that indicate the size of hidden layer</dd>
<dt><strong><code>alphabet_offset</code></strong> :&ensp;<code>int</code></dt>
<dd>Indicate the minimal number of neurons in hidden layer</dd>
<dt><strong><code>update_gen_cycle</code></strong> :&ensp;<code>int</code></dt>
<dd>Refresh tensorflow random generator per update_gen_cycle</dd>
<dt><strong><code>callbacks</code></strong> :&ensp;<code>list</code></dt>
<dd>Callbacks for neural networks training</dd>
<dt><strong><code>file_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to file for logging</dd>
<dt><strong><code>logging</code></strong> :&ensp;<code>bool</code></dt>
<dd>Logging search process to file</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>search_results</code></strong> :&ensp;<code>tuple[float, int, str, str, dict]</code></dt>
<dd>
<p>Results of the algorithm are described by these parameters</p>
<p>best_loss: float
The value of the loss function during training of the best neural network
best_epoch: int
Number of training epochs for the best neural network
best_loss_func: str
Name of the loss function of the best neural network
best_opt: str
Name of the optimizer of the best neural network
best_net: dict
Best neural network presented as a dictionary</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simulated_annealing(
    input_size: int,
    output_size: int,
    data: tuple,
    val_data: tuple = None,
    max_iter: int = 100,
    threshold: float = -1,
    start_net: dict = None,
    method_for_generate_next_nn: Callable = generate_neighbor,
    temperature_method: Callable = temperature_lin,
    distance_method: Callable = distance_const(150),
    min_epoch: int = 100,
    max_epoch: int = 700,
    opt: str = &#34;Adam&#34;,
    loss: str = &#34;Huber&#34;,
    nn_min_length: int = 1,
    nn_max_length: int = 6,
    nn_alphabet: list[str] = [
        &#34;&#34;.join(elem) for elem in product(alph_n_full, alphabet_activations)
    ],
    alphabet_block_size: int = 1,
    alphabet_offset: int = 8,
    update_gen_cycle: int = 0,
    callbacks: list = None,
    file_name: str = &#34;&#34;,
    logging: bool = False,
) -&gt; Tuple[float, int, str, str, dict, int]:
    &#34;&#34;&#34;
    Method of simulated annealing in the parameter space of neural networks
    
    Parameters
    ----------
    input_size: int
       Size of input data
    output_size: int
        Size of output data
    data: tuple
        dataset
    val_data: tuple
        Validation dataset
    max_iter: int
        Training will stop when the number of iterations of the algorithm exceeds this parameter
    threshold: float
        Training will stop when the value of the loss function is less than this threshold
    start_net: dict
        Start point in parameter space of neural networks, if None it will be random generated
    method_for_generate_next_nn: Callable
        Method for obtaining the next point in parameter space of neural networks
    temperature_method: Callable
        Temperature decreasing method in SAM
    distance_method: Callable
        Method that sets the boundaries of the neighborhood around the current point
    min_epoch: int
        Lower bound of epochs
    max_epoch: int
        Upper bound of epochs
    opt: str
        Name of optimizer
    loss: str
        Name of loss function
    nn_min_length: int
        Starting number of hidden layers of neural networks
    nn_max_length: int
        Final number of hidden layers of neural networks
    nn_alphabet: list
        List of possible sizes of hidden layers with activations for them
    alphabet_block_size: int
        Number of literals in each `alphabet` symbol that indicate the size of hidden layer
    alphabet_offset: int
        Indicate the minimal number of neurons in hidden layer
    update_gen_cycle: int
        Refresh tensorflow random generator per update_gen_cycle
    callbacks: list
        Callbacks for neural networks training
    file_name: str
        Path to file for logging
    logging: bool
        Logging search process to file

    Returns
    -------
    search_results: tuple[float, int, str, str, dict]
        Results of the algorithm are described by these parameters

        best_loss: float
            The value of the loss function during training of the best neural network
        best_epoch: int
            Number of training epochs for the best neural network
        best_loss_func: str
            Name of the loss function of the best neural network
        best_opt: str
            Name of the optimizer of the best neural network
        best_net: dict
            Best neural network presented as a dictionary
    &#34;&#34;&#34;
    gen = random_generate(
        min_epoch=min_epoch,
        max_epoch=max_epoch,
        min_length=nn_min_length,
        max_length=nn_max_length,
        alphabet=nn_alphabet,
    )
    if start_net is None:
        b, a = decode(
            gen[0].value(), block_size=alphabet_block_size, offset=alphabet_offset
        )
        curr_best = imodel.IModel(input_size, b, output_size, a + [&#34;linear&#34;])
        curr_best.compile(optimizer=opt, loss_func=loss)
    else:
        curr_best = imodel.IModel(input_size, [], output_size, [&#34;linear&#34;])
        curr_best = curr_best.from_dict(start_net)
    curr_epoch = gen[1].value()
    hist = curr_best.train(
        data[0], data[1], epochs=curr_epoch, verbose=0, callbacks=callbacks
    )
    curr_loss = hist.history[&#34;loss&#34;][-1]
    best_val_loss = (
        curr_best.evaluate(val_data[0], val_data[1], verbose=0, return_dict=True)[
            &#34;loss&#34;
        ]
        if val_data is not None
        else None
    )
    best_epoch = curr_epoch
    best_nn = curr_best.to_dict()
    best_gen = gen
    best_a = curr_best.get_activations
    best_loss = curr_loss

    history = dict()
    history[&#34;shapes&#34;] = [curr_best.get_shape]
    history[&#34;activations&#34;] = [best_a]
    history[&#34;code&#34;] = [best_gen[0].value()]
    history[&#34;epoch&#34;] = [best_gen[1].value()]
    history[&#34;optimizer&#34;] = [opt]
    history[&#34;loss function&#34;] = [loss]
    history[&#34;loss&#34;] = [curr_loss]
    history[&#34;validation loss&#34;] = [best_val_loss]
    history[&#34;train_time&#34;] = [curr_best.network.trained_time[&#34;train_time&#34;]]
    if logging:
        fn = f&#34;{file_name}_{len(data[0])}_0_{loss}_{opt}&#34;
        log_to_file(history, fn)

    k = 0
    t = 1
    while k &lt; max_iter - 1 and curr_loss &gt; threshold:
        history = dict()

        update_random_generator(k, cycle_size=update_gen_cycle)
        t = temperature_method(k=k, k_max=max_iter, t=t)
        distance = distance_method(temperature=t)

        gen_neighbor = choose_neighbor(
            method_for_generate_next_nn,
            alphabet=nn_alphabet,
            parameters=(gen[0].value(), gen[1].value()),
            distance=distance,
            min_epoch=min_epoch,
            max_epoch=max_epoch,
            min_length=nn_min_length,
            max_length=nn_max_length,
        )
        b, a = decode(
            gen_neighbor[0].value(),
            block_size=alphabet_block_size,
            offset=alphabet_offset,
        )
        neighbor = imodel.IModel(input_size, b, output_size, a + [&#34;linear&#34;])
        neighbor.compile(optimizer=opt, loss_func=loss)
        neighbor_hist = neighbor.train(
            data[0],
            data[1],
            epochs=gen_neighbor[1].value(),
            verbose=0,
            callbacks=callbacks,
        )
        neighbor_val_loss = (
            neighbor.evaluate(val_data[0], val_data[1], verbose=0, return_dict=True)[
                &#34;loss&#34;
            ]
            if val_data is not None
            else None
        )
        neighbor_loss = neighbor_hist.history[&#34;loss&#34;][-1]

        if (
            neighbor_loss &lt; curr_loss
            or math.e ** ((curr_loss - neighbor_loss) / t) &gt; random.random()
        ):
            curr_best = neighbor
            gen = gen_neighbor
            curr_epoch = gen_neighbor[1].value()
            curr_loss = neighbor_loss
            curr_val_loss = neighbor_val_loss

            if curr_loss &lt; best_loss:
                best_loss = curr_loss
                best_epoch = curr_epoch
                best_nn = curr_best.to_dict()
                best_gen = gen
                best_a = a.copy()
                best_val_loss = curr_val_loss
        k += 1

        history[&#34;shapes&#34;] = [neighbor.get_shape]
        history[&#34;activations&#34;] = [a]
        history[&#34;code&#34;] = [gen_neighbor[0].value()]
        history[&#34;epoch&#34;] = [gen_neighbor[1].value()]
        history[&#34;optimizer&#34;] = [opt]
        history[&#34;loss function&#34;] = [loss]
        history[&#34;loss&#34;] = [neighbor_loss]
        history[&#34;validation loss&#34;] = [neighbor_val_loss]
        history[&#34;train_time&#34;] = [neighbor.network.trained_time[&#34;train_time&#34;]]
        if logging:
            fn = f&#34;{file_name}_{len(data[0])}_0_{loss}_{opt}&#34;
            log_to_file(history, fn)
    return best_loss, best_epoch, loss, opt, best_nn, k</code></pre>
</details>
</dd>
<dt id="degann.search_algorithms.simulated_annealing.temperature_exp"><code class="name flex">
<span>def <span class="ident">temperature_exp</span></span>(<span>alpha: float) ‑> Callable[[float], float]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate new temperature for simulated annealing as <em>t * alpha</em></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>alpha</code></strong> :&ensp;<code>float</code></dt>
<dd>Exponential exponent</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>t_e</code></strong> :&ensp;<code>Callable[[float], float]</code></dt>
<dd>Temperature function</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def temperature_exp(alpha: float) -&gt; Callable[[float], float]:
    &#34;&#34;&#34;
    Calculate new temperature for simulated annealing as *t * alpha*

    Parameters
    ----------
    alpha: float
        Exponential exponent

    Returns
    -------
    t_e: Callable[[float], float]
        Temperature function
    &#34;&#34;&#34;

    def t_e(t: float, **kwargs) -&gt; float:
        &#34;&#34;&#34;
        Parameters
        ----------
        t: float
            Current temperature

        Returns
        -------
        new_t: float
            New temperature
        &#34;&#34;&#34;
        return t * alpha

    return t_e</code></pre>
</details>
</dd>
<dt id="degann.search_algorithms.simulated_annealing.temperature_lin"><code class="name flex">
<span>def <span class="ident">temperature_lin</span></span>(<span>k: int, k_max: int, **kwargs) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate new temperature for simulated annealing as <em>1 - (k + 1) / k_max</em></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>k</code></strong> :&ensp;<code>float</code></dt>
<dd>Current iteration</dd>
<dt><strong><code>k_max</code></strong> :&ensp;<code>float</code></dt>
<dd>Amount of all iterations</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>new_t</code></strong> :&ensp;<code>float</code></dt>
<dd>New temperature</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def temperature_lin(k: int, k_max: int, **kwargs) -&gt; float:
    &#34;&#34;&#34;
    Calculate new temperature for simulated annealing as *1 - (k + 1) / k_max*

    Parameters
    ----------
    k: float
        Current iteration
    k_max: float
        Amount of all iterations

    Returns
    -------
    new_t: float
        New temperature
    &#34;&#34;&#34;
    return 1 - (k + 1) / k_max</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="degann.search_algorithms" href="index.html">degann.search_algorithms</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="degann.search_algorithms.simulated_annealing.distance_const" href="#degann.search_algorithms.simulated_annealing.distance_const">distance_const</a></code></li>
<li><code><a title="degann.search_algorithms.simulated_annealing.distance_lin" href="#degann.search_algorithms.simulated_annealing.distance_lin">distance_lin</a></code></li>
<li><code><a title="degann.search_algorithms.simulated_annealing.simulated_annealing" href="#degann.search_algorithms.simulated_annealing.simulated_annealing">simulated_annealing</a></code></li>
<li><code><a title="degann.search_algorithms.simulated_annealing.temperature_exp" href="#degann.search_algorithms.simulated_annealing.temperature_exp">temperature_exp</a></code></li>
<li><code><a title="degann.search_algorithms.simulated_annealing.temperature_lin" href="#degann.search_algorithms.simulated_annealing.temperature_lin">temperature_lin</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>